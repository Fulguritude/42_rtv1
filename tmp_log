diff --git a/camera.c b/camera.c
deleted file mode 100644
index cfb2f18..0000000
--- a/camera.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   camera.c                                           :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: fulguritude <marvin@42.fr>                 +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2018/06/11 00:31:44 by fulguritu         #+#    #+#             */
-/*   Updated: 2018/07/19 15:23:48 by tduquesn         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "rtv1.h"
-
-static void		build_cam_matrices(t_camera *cam)
-{
-	t_mat_3b3	tmp;
-	t_vec_3d	v;
-	t_mat_4b4	result;
-
-	mat33_set(tmp, cam->axis_x, cam->axis_y, cam->axis_z);
-	result[0] = tmp[0];
-	result[1] = tmp[1];
-	result[2] = tmp[2];
-	result[3] = 0.;
-	result[4] = tmp[3];
-	result[5] = tmp[4];
-	result[6] = tmp[5];
-	result[7] = 0.;
-	result[8] = tmp[6];
-	result[9] = tmp[7];
-	result[10] = tmp[8];
-	result[11] = 0.;
-	vec3_sub(v, cam->world_pos, cam->anchor); //TODO maybe needs fixing
-	result[12] = v[0];
-	result[13] = v[1];
-	result[14] = v[2];
-	result[15] = 1.;
-	ft_memcpy(cam->c_to_w, result, T_MAT44_SIZE);
-	mat44_inv(result, result);
-	ft_memcpy(cam->w_to_c, result, T_MAT44_SIZE);
-}
-
-t_camera		init_cam(t_vec_3d polar_cam_pos)
-{
-	t_camera	result;
-
-	vec3_set(result.anchor, 0., 0., 0.);
-	vec3_cpy(result.polar_pos, polar_cam_pos);
-	vec3_polar_to_cartesian(result.world_pos, polar_cam_pos);
-//	vec3_add(ctrl->cam.reltv_pos, ctrl->cam.world_pos, ctrl->cam.anchor);
-	vec3_sub(result.axis_z, result.world_pos, result.anchor);
-	vec3_eucl_nrmlz(result.axis_z, result.axis_z);
-	vec3_set(result.axis_y, 0., 1., 0.);
-	vec3_cross(result.axis_x, result.axis_y, result.axis_z);
-	vec3_eucl_nrmlz(result.axis_x, result.axis_x);
-	vec3_cross(result.axis_y, result.axis_x, result.axis_z);
-//	vec3_eucl_nrmlz(result.axis_y, result.axis_y);
-//	vec3_scale(result.axis_x, 1., result.axis_x);
-
-printf("cam:\n\tx: (%.5f, %.5f, %.5f)\n\ty: (%.5f, %.5f, %.5f)\n\tz: (%.5f, %.5f, %.5f)\n\n",
-result.axis_x[0], result.axis_x[1], result.axis_x[2],
-result.axis_y[0], result.axis_y[1], result.axis_y[2],
-result.axis_z[0], result.axis_z[1], result.axis_z[2]);
-
-	result.hrz_fov = 0.8;
-	build_cam_matrices(&result);
-
-printf("c_to_w:\n\tx: (%.5f, %.5f, %.5f, %.5f)\n\ty: (%.5f, %.5f, %.5f, %.5f)\n\tz: (%.5f, %.5f, %.5f, %.5f)\n\tt: (%.5f, %.5f, %.5f, %.5f)\n\n",
-result.c_to_w[0], result.c_to_w[1], result.c_to_w[2], result.c_to_w[3],
-result.c_to_w[4], result.c_to_w[5], result.c_to_w[6], result.c_to_w[7],
-result.c_to_w[8], result.c_to_w[9], result.c_to_w[10], result.c_to_w[11],
-result.c_to_w[12], result.c_to_w[13], result.c_to_w[14], result.c_to_w[15]);
-
-printf("w_to_c:\n\tx: (%.5f, %.5f, %.5f, %.5f)\n\ty: (%.5f, %.5f, %.5f, %.5f)\n\tz: (%.5f, %.5f, %.5f, %.5f)\n\tt: (%.5f, %.5f, %.5f, %.5f)\n\n",
-result.w_to_c[0], result.w_to_c[1], result.w_to_c[2], result.w_to_c[3],
-result.w_to_c[4], result.w_to_c[5], result.w_to_c[6], result.w_to_c[7],
-result.w_to_c[8], result.w_to_c[9], result.w_to_c[10], result.w_to_c[11],
-result.w_to_c[12], result.w_to_c[13], result.w_to_c[14], result.w_to_c[15]);
-
-	return (result);
-}
diff --git a/coordinates.c b/coordinates.c
deleted file mode 100644
index d1e5e23..0000000
--- a/coordinates.c
+++ /dev/null
@@ -1,51 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   coordinates.c                                      :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: fulguritude <marvin@42.fr>                 +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2018/06/01 02:55:50 by fulguritu         #+#    #+#             */
-/*   Updated: 2018/06/01 02:56:02 by fulguritu        ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "rtv1.h"
-
-void		vec3_polar_to_cartesian(t_vec_3d result, t_vec_3d const src)
-{
-	t_float		r;
-	t_float		sin_lat;
-
-	r = src[0];
-	sin_lat = sin(src[2]);
-	result[0] = r * sin_lat * cos(src[1]);
-	result[2] = r * sin_lat * sin(src[1]);
-	result[1] = r * cos(src[2]);
-}
-
-/*
-** Longitude is East/west, latitude is north/south
-*/
-
-void		vec3_cartesian_to_polar(t_vec_3d result, t_vec_3d const src)
-{
-	t_float		r;
-	t_float		tmp;
-	t_float		lat;
-	t_float		lon;
-
-	r = sqrt(src[0] * src[0] + src[1] * src[1] + src[2] * src[2]);
-	if (r == 0.)
-	{
-		write(2, "null vec3 cannot be converted to polar coordinates\n", 31);
-		vec3_set(result, 0., 0., 0.);
-		return ;
-	}
-	tmp = src[0] == 0. ? 0.001 : src[0];
-	lon = atan(src[1] / tmp);
-	lat = acos(src[2] / r);
-	result[0] = r;
-	result[1] = lon;
-	result[2] = lat;
-}
diff --git a/event_key.c b/event_key.c
deleted file mode 100644
index 5a8fae5..0000000
--- a/event_key.c
+++ /dev/null
@@ -1,103 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   event_key.c                                        :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: fulguritude <marvin@42.fr>                 +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2018/07/14 20:49:10 by fulguritu         #+#    #+#             */
-/*   Updated: 2018/07/14 20:49:13 by fulguritu        ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "rtv1.h"
-
-#if 0
-static int	handle_key_palette(int key, t_control *ctrl)
-{
-	int		status;
-
-	status = -1;
-	if (key == KEY_NUMPAD_0)
-		status = 0;
-	else if (key == KEY_NUMPAD_1)
-		status = 1;
-	else if (key == KEY_NUMPAD_2)
-		status = 2;
-	else if (key == KEY_NUMPAD_3)
-		status = 3;
-	else if (key == KEY_NUMPAD_4)
-		status = 4;
-	else if (key == KEY_NUMPAD_5)
-		status = 5;
-	else if (key == KEY_NUMPAD_6)
-		status = 6;
-	else if (key == KEY_NUMPAD_7)
-		status = 7;
-	else if (key == KEY_NUMPAD_8)
-		status = 8;
-	else if (key == KEY_NUMPAD_9)
-		status = 9;
-	ctrl->fractol.palette = status == -1 ? ctrl->fractol.palette : status;
-	return (status != -1);
-}
-
-static int	handle_key_window(int key, t_control *ctrl)
-{
-	int					status;
-	static t_float		zoom_trans_ratio = 0.04;
-
-	status = 1;
-	if (key == KEY_RIGHT)
-		ctrl->fractol.anchor.re -= zoom_trans_ratio * ctrl->fractol.zoom;
-	else if (key == KEY_LEFT)
-		ctrl->fractol.anchor.re += zoom_trans_ratio * ctrl->fractol.zoom;
-	else if (key == KEY_UP)
-		ctrl->fractol.anchor.im += zoom_trans_ratio * ctrl->fractol.zoom;
-	else if (key == KEY_DOWN)
-		ctrl->fractol.anchor.im -= zoom_trans_ratio * ctrl->fractol.zoom;
-	else if (key == KEY_PAGE_UP)
-		ctrl->fractol.zoom *= 1.25;
-	else if (key == KEY_PAGE_DN)
-		ctrl->fractol.zoom *= 0.8;
-	else if (key == KEY_LCTRL)
-		ctrl->debug = !(ctrl->debug);
-	else if (key == KEY_RCTRL)
-		ctrl->render_mode = (ctrl->render_mode + 1) == 3 ?
-									0 : ctrl->render_mode + 1;
-	else
-		status = 0;
-	return (status);
-}
-#endif
-
-int			handle_key(int key, void *param)
-{
-	t_control			*ctrl;
-
-	ctrl = (t_control *)param;
-	if (key == KEY_ESC)
-		exit_error("Software closing.", 0);
-	else if (key == KEY_LCTRL)
-		ctrl->debug = !(ctrl->debug);
-	else if (key == KEY_PAGE_DN)
-		ctrl->cam.polar_pos[0] *= 1.1;
-	else if (key == KEY_PAGE_UP)
-		ctrl->cam.polar_pos[0] *= 0.9;
-	else if (key == KEY_LEFT)
-		ctrl->cam.polar_pos[1] -= 0.2;
-	else if (key == KEY_RIGHT)
-		ctrl->cam.polar_pos[1] += 0.2;
-	else if (key == KEY_DOWN && ctrl->cam.polar_pos[2] - 0.1 > -0.00001)
-		ctrl->cam.polar_pos[2] -= 0.1;
-	else if (key == KEY_UP && ctrl->cam.polar_pos[2] + 0.1 < PI + 0.00001)
-		ctrl->cam.polar_pos[2] += 0.1;
-	else
-		return (1);
-//	else if (key == KEY_SPACE)
-//	else if (key == KEY_HOME)
-//	else if (!has_changed)
-//		return (1);
-	render(ctrl);
-	return (0);
-}
diff --git a/event_mouse.c b/event_mouse.c
deleted file mode 100644
index 4e5d9c5..0000000
--- a/event_mouse.c
+++ /dev/null
@@ -1,229 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   event_mouse.c                                      :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: fulguritude <marvin@42.fr>                 +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2018/05/18 03:33:15 by fulguritu         #+#    #+#             */
-/*   Updated: 2018/08/05 22:12:41 by tduquesn         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "rtv1.h"
-
-/*
-** "Key hook"
-*/
-
-#if 0
-static void		handle_resize_key(int key, t_control *ctrl)
-{
-	if (key == KEY_PAGE_DN)
-		ctrl->cam.polar_pos[0] *= 1.1;
-	else if (key == KEY_PAGE_UP)
-		ctrl->cam.polar_pos[0] *= 0.9;
-	else if (key == KEY_NUMPAD_ADD)
-		ctrl->fdf.h_scale += 0.5;
-	else if (key == KEY_NUMPAD_SUB)
-		ctrl->fdf.h_scale -= 0.5;
-}
-
-int				handle_key(int key, void *param)
-{
-	t_control	*ctrl;
-
-	ctrl = (t_control *)param;
-	if (key == KEY_SPACE)
-		toggle_proj(ctrl);
-	else if (key == KEY_LCTRL)
-		toggle_debug(ctrl);
-	else if (key == KEY_LEFT)
-		ctrl->cam.polar_pos[1] -= 0.2;
-	else if (key == KEY_RIGHT)
-		ctrl->cam.polar_pos[1] += 0.2;
-	else if (key == KEY_DOWN && ctrl->cam.polar_pos[2] - 0.1 > 0)
-		ctrl->cam.polar_pos[2] -= 0.1;
-	else if (key == KEY_UP && ctrl->cam.polar_pos[2] + 0.1 < PI)
-		ctrl->cam.polar_pos[2] += 0.1;
-	else if (key == KEY_ESC)
-		exit_error("Software closing.", 0);
-	else
-		handle_resize_key(key, ctrl);
-	vec3_polar_to_cartesian(ctrl->cam.world_pos, ctrl->cam.polar_pos);
-	vec3_add(ctrl->cam.world_pos, ctrl->cam.world_pos, ctrl->cam.anchor);
-	ctrl->cam = init_cam(ctrl->cam.polar_pos);
-	handle_redraw(param);
-	return (0);
-}
-
-/*
-** "Mouse hook"
-*/
-
-int				handle_mouse(int button, int x, int y, void *param)
-{
-	t_control			*ctrl;
-	static int			click_nb = -1;
-	static t_gridpoint	last_click_coord;
-	t_gridpoint			tmp;
-
-	++click_nb;
-	ctrl = (t_control*)param;
-	if (button == L_CLICK)
-		mlx_pixel_put(ctrl->mlx_ptr, ctrl->win_ptr, x, y, BLUE);
-	else if (button == R_CLICK)
-		mlx_pixel_put(ctrl->mlx_ptr, ctrl->win_ptr, x, y, GREEN);
-	if (click_nb == 1)
-	{
-		tmp.x = x + HALF_DRENWIN_WIDTH;
-		tmp.y = y + HALF_DRENWIN_HEIGHT;
-		bresenham(ctrl, last_click_coord, tmp);
-		click_nb = -1;
-	}
-	last_click_coord.x = x + HALF_DRENWIN_WIDTH;
-	last_click_coord.y = y + HALF_DRENWIN_WIDTH;
-	mlx_put_image_to_window(ctrl->mlx_ptr, ctrl->win_ptr, ctrl->img_ptr,
-							-HALF_DRENWIN_WIDTH, -HALF_DRENWIN_HEIGHT);
-	return (0);
-}
-
-/*
-** "Expose hook"
-*/
-
-static void		handle_redraw_helper(t_control *ctrl)
-{
-	t_gridpoint		vtx1_pixmap_pos;
-	t_gridpoint		vtx2_pixmap_pos;
-	int				i;
-
-	i = -1;
-	while (++i < ctrl->fdf.edge_lst_len)
-	{
-		vtx1_pixmap_pos = ctrl->fdf.edge_lst[i].vtx_from->proj_pos;
-		vtx2_pixmap_pos = ctrl->fdf.edge_lst[i].vtx_to->proj_pos;
-		vtx1_pixmap_pos.x += REN_WIDTH / 2;
-		vtx1_pixmap_pos.y += REN_HEIGHT / 2;
-		vtx2_pixmap_pos.x += REN_WIDTH / 2;
-		vtx2_pixmap_pos.y += REN_HEIGHT / 2;
-		if (point_in_bounds(vtx1_pixmap_pos.x, vtx1_pixmap_pos.y)
-				&& point_in_bounds(vtx2_pixmap_pos.x, vtx2_pixmap_pos.y))
-			bresenham(ctrl, vtx1_pixmap_pos, vtx2_pixmap_pos);
-	}
-	mlx_put_image_to_window(ctrl->mlx_ptr, ctrl->win_ptr, ctrl->img_ptr,
-							-HALF_DRENWIN_WIDTH, -HALF_DRENWIN_HEIGHT);
-	if (ctrl->debug)
-		show_debug_info(ctrl);
-}
-
-int				handle_redraw(void *param)
-{
-	t_control	*ctrl;
-	t_mat_4b4	w_to_v;
-	t_vec_4d	tmp;
-	int			i;
-
-	ctrl = (t_control *)param;
-	mlximg_clear(ctrl);
-	i = -1;
-	cam_to_mat(w_to_v, ctrl->cam);
-	while (++i < ctrl->fdf.vtx_lst_len)
-	{
-		vec3_cpy((t_float *)tmp, ctrl->fdf.vtx_lst[i].world_pos);
-		tmp[2] *= ctrl->fdf.h_scale;
-		tmp[3] = 1.;
-		mat44_app_vec(tmp, w_to_v, tmp);
-		vec3_sub(ctrl->fdf.vtx_lst[i].view_pos, tmp, ((t_float *)w_to_v) + 12);
-		vec3_scale(ctrl->fdf.vtx_lst[i].view_pos, 10. * ctrl->cam.polar_pos[0],
-					ctrl->fdf.vtx_lst[i].view_pos);
-		ctrl->fdf.vtx_lst[i].proj_pos =
-					ctrl->proj((t_float *)(ctrl->fdf.vtx_lst[i].view_pos));
-	}
-	handle_redraw_helper(ctrl);
-	return (0);
-}
-#endif
-
-/*
-** It is with the mlx_hook function that one creates custom hooks. funct can
-** take any number/types of arguments.
-**
-** int	mlx_hook(t_win_list *win, int x_event, int x_mask, 
-**		 int (*funct)(),void *param)
-** {
-**  win->hooks[x_event].hook = funct;
-**  win->hooks[x_event].param = param;
-**  win->hooks[x_event].mask = x_mask;
-** }
-*/
-
-int		handle_mouse_press(int button, int x, int y, void *param)
-{
-	t_control		*ctrl;
-	static int		no_render = 1;
-	static t_point	prev_press = {-1, -1};
-
-	ctrl = (t_control *)param;
-	if (button == SCROLL_UP || button == SCROLL_DOWN)
-	{
-		if (prev_press.x != x || prev_press.y != y)
-		{
-			ctrl->fractol.anchor =
-					get_complex_from_point(&(ctrl->fractol), x, y);
-			prev_press.x = x;
-			prev_press.y = y;
-		}
-		ctrl->fractol.zoom *= (button == SCROLL_UP) ? 0.9 : 1.1;
-		if (no_render >= 3)
-		{
-			no_render = 0;
-			render(ctrl);
-		}
-		else
-			++no_render;
-	}
-	return (0);
-}
-
-int		handle_mouse_release(int button, int x, int y, void *param)
-{
-	t_control		*ctrl;
-
-	ctrl = (t_control *)param;
-	if (button == L_CLICK)
-	{
-		ctrl->fractol.anchor = get_complex_from_point(&(ctrl->fractol), x, y);
-		render(ctrl);
-	}
-	return (OK);
-}
-
-int		handle_mouse_move(int x, int y, void *param)
-{
-	t_control		*ctrl;
-	static t_u32	no_render = 1;
-	t_u32			mouse_speed;
-
-	ctrl = (t_control *)param;
-	if (!(ctrl->fractol.is_static))
-	{
-		if (ctrl->fractol.type == newton)
-			ctrl->fractol.param =
-					get_complex_from_point(&(ctrl->fractol), x, y);
-		else
-			ctrl->fractol.iter_cpoly.coefs[ctrl->fractol.cur_coef] =
-					get_complex_from_point(&(ctrl->fractol), x, y);
-		mouse_speed = (ctrl->mouse.x - x) * (ctrl->mouse.x - x)
-					+ (ctrl->mouse.y - y) * (ctrl->mouse.y - y);
-		if (no_render >= 5 * mouse_speed || (mouse_speed < 4 && no_render >= 5))
-		{
-			no_render = 0;
-			render(ctrl);
-		}
-		else
-			++no_render;
-	}
-	ctrl->mouse = (t_point){x, y};
-	return (OK);
-}
diff --git a/image_utils.c b/image_utils.c
deleted file mode 100644
index 36815ae..0000000
--- a/image_utils.c
+++ /dev/null
@@ -1,53 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   image_utils.c                                      :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: fulguritude <marvin@42.fr>                 +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2018/05/18 03:33:40 by fulguritu         #+#    #+#             */
-/*   Updated: 2018/05/18 03:33:53 by fulguritu        ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "rtv1.h"
-
-/*
-** mlx_put_image_to_window(ctrl->mlx_ptr, ctrl->win_ptr, ctrl->img_ptr,
-**							xoffset, yoffset);
-*/
-
-/*
-** ctrl->img_data[y * ctrl->img_bpl + x * ctrl->img_bpp]  = color & 0xFF000000;
-** ctrl->img_data[y * ctrl->img_bpl + x * ctrl->img_bpp+1]= color & 0x00FF0000;
-** etc, watch out for endianness
-** The following trick only works because img_bpp = 32 / 8 = 4
-*/
-
-inline void		mlximg_setpixel(t_control *ctrl, t_s32 color, t_s32 x, t_s32 y)
-{
-	((t_u32 *)ctrl->img_data)[y * ctrl->img_bpl / 4 + x] = (t_u32)color;
-}
-
-inline void		mlximg_clear(t_control *ctrl)
-{
-	ft_bzero(ctrl->img_data, ctrl->img_bytelen);
-}
-
-void			mlximg_fill(t_control *ctrl, t_u32 val)
-{
-	t_u32			i;
-	static t_u32	pixels = REN_W * REN_H;
-
-	i = 0;
-	while (i < pixels)
-	{
-		((t_u32 *)ctrl->img_data)[i] = val;
-		++i;
-	}
-}
-
-inline int		point_in_bounds(t_s32 x, t_s32 y)
-{
-	return (0 <= x && x < REN_W && 0 <= y && y < REN_H);
-}
diff --git a/intersect.c b/intersect.c
deleted file mode 100644
index e1bb1b4..0000000
--- a/intersect.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   intersect.c                                        :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: fulguritude <marvin@42.fr>                 +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2018/09/16 22:59:05 by fulguritu         #+#    #+#             */
-/*   Updated: 2018/09/16 23:00:18 by fulguritu        ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "rtv1.h"
-
-//rename sphere_intersect_ray and make this sphere.c ?
-
-/*
-** Should sphr.center in world_pos or view_pos ?
-**
-** Replace with a t_vec3 for coefs ?
-**
-** replace everything with ray as a pointer with t = inf at first, and return
-** false if the intersection is behind (o + t*dir)  ? 
-*/
-t_bool		intersect_ray_sphere(t_ray *ray, t_sphere const sphr)
-{
-	t_float		delta;
-	t_float		b;
-	t_float		c;
-	t_float		root1;
-	t_float		root2;
-	t_vec_3d	orig_to_sphr;
-
-	vec3_sub(orig_to_sphr, ray->origin, sphr.center);
-	b = 2 * vec3_dot(ray->dir, orig_to_sphr);
-	c = vec3_eucl_quadnorm(orig_to_sphr) - sphr.radius * sphr.radius;
-	delta = b * b - 4 * c;
-	if (delta < 0.)
-		return (FALSE);
-	delta = sqrt(delta);
-	root1 = (-b + delta) * 0.5;
-	root2 = (-b - delta) * 0.5;
-	if (root1 <= 0. || root2 <= 0. || (root1 > ray->t && root2 > ray->t))
-		return (FALSE);
-	ray->t = ft_fmin(root1, root2);
-	return (TRUE);
-}
-
-void		sphere_get_ctt_n_nrml(t_vec_3d contact, t_vec_3d normal,
-									t_ray const ray, t_sphere const sphr)
-{
-	vec3_scale(contact, ray.t, ray.dir);
-	vec3_add(contact, contact, ray.origin); //pos relative to ray->origin, which itself should be in world_pos
-	vec3_sub(normal, contact, sphr.center);
-	vec3_scale(normal, 1. / sphr.radius, normal);
-}
-
-void		sphere_wtoc(t_sphere *sphr, t_camera const cam)
-{
-	t_vec_4d	tmp;
-
-	vec3_cpy(tmp, sphr->center);
-	tmp[3] = 1.;
-	mat44_app_vec(tmp, cam.w_to_c, tmp);
-	vec3_cpy(sphr->center, tmp);
-}
-
-
-//parrallelepiped, cone, cylinder
diff --git a/libft/src/math/algebra/mat33.c b/libft/src/math/algebra/mat33.c
index b17295b..316c3a4 100644
--- a/libft/src/math/algebra/mat33.c
+++ b/libft/src/math/algebra/mat33.c
@@ -77,11 +77,17 @@ void			mat33_rot(t_mat_3b3 result, t_float theta, int_fast8_t axis)
 	c_th = cosf(theta);
 	s_th = sinf(theta);
 	if (axis == 0)
-		mat33_set(result, (t_vec_3d){1., 0., 0.}, (t_vec_3d){0., c_th, s_th}, (t_vec_3d){0., -s_th, c_th});
+		mat33_set(result, (t_vec_3d){1., 0., 0.},
+						(t_vec_3d){0., c_th, s_th},
+						(t_vec_3d){0., -s_th, c_th});
 	else if (axis == 1)
-		mat33_set(result, (t_vec_3d){c_th, 0., -s_th}, (t_vec_3d){0., 1., 0.}, (t_vec_3d){s_th, 0., c_th});
+		mat33_set(result, (t_vec_3d){c_th, 0., -s_th},
+						(t_vec_3d){0., 1., 0.},
+						(t_vec_3d){s_th, 0., c_th});
 	else
-		mat33_set(result, (t_vec_3d){c_th, s_th, 0.}, (t_vec_3d){-s_th, c_th, 0.}, (t_vec_3d){0., 0., 1.});
+		mat33_set(result, (t_vec_3d){c_th, s_th, 0.},
+						(t_vec_3d){-s_th, c_th, 0.},
+						(t_vec_3d){0., 0., 1.});
 }
 
 void			mat33_set_diagmat(t_mat_3b3 result, t_vec_3d const coefs)
diff --git a/main_rtv1.c b/main_rtv1.c
deleted file mode 100644
index fba0c8b..0000000
--- a/main_rtv1.c
+++ /dev/null
@@ -1,97 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   main_rtv1.c                                        :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: fulguritude <marvin@42.fr>                 +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2018/08/30 20:27:46 by fulguritu         #+#    #+#             */
-/*   Updated: 2018/09/10 03:17:01 by fulguritu        ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "rtv1.h"
-
-void			exit_error(char *e_msg, int e_no)
-{
-	int		i;
-
-	if (e_no == 0)
-	{
-		i = write(2, e_msg, ft_strlen(e_msg));
-		i += write(2, "\n", 1);
-		exit(i);
-	}
-	else
-		perror(e_msg);
-	exit(e_no);
-}
-
-/*
-** Bits per pixel (32, each color is an int) are immediately converted to
-** bytes per pixel.
-**
-** Anchor is which point of the complex plane is the center of the window.
-*/
-
-static void		init_mlx(t_control *ctrl)
-{
-	if (!(ctrl->mlx_ptr = mlx_init()))
-		exit_error("could not init mlx_ptr", 0);
-	if (!(ctrl->win_ptr = mlx_new_window(ctrl->mlx_ptr,
-				REN_W, REN_H, "RTv1")))
-		exit_error("could not init win_ptr", 0);
-	if (!(ctrl->img_ptr = mlx_new_image(ctrl->mlx_ptr, REN_W, REN_H)))
-		exit_error("could not init img_ptr", 0);
-	if (!(ctrl->img_data = mlx_get_data_addr(ctrl->img_ptr, &(ctrl->img_bpp),
-										&(ctrl->img_bpl), &(ctrl->endian))))
-		exit_error("could not retrieve img data ptr and other info", 0);
-	ctrl->img_bpp = ctrl->img_bpp / 8;
-	ctrl->img_pixel_nb = REN_W * REN_H;
-	ctrl->img_bytelen = ctrl->img_bpp * ctrl->img_pixel_nb;
-	ctrl->debug = 1;
-}
-
-/*
-** MASK_POINTERMOTION returns true when the mouse moves, when no button is
-**		clicked;
-*/
-/*
-static void		init_mouse_events(t_control *ctrl)
-{
-	int		event;
-	int		mask;
-
-	mlx_key_hook(ctrl->win_ptr, &handle_key, ctrl);
-	mask = MASK_POINTERMOTION | MASK_BUTTON1MOTION |
-				MASK_BUTTON2MOTION | MASK_BUTTON3MOTION;
-	event = EVENT_MOTIONNOTIFY;
-	mlx_hook(ctrl->win_ptr, event, mask, handle_mouse_move, ctrl);
-	mask = MASK_BUTTONPRESS;
-	event = EVENT_BUTTONPRESS;
-	mlx_hook(ctrl->win_ptr, event, mask, handle_mouse_press, ctrl);
-	mask = MASK_BUTTONRELEASE;
-	event = EVENT_BUTTONRELEASE;
-	mlx_hook(ctrl->win_ptr, event, mask, handle_mouse_release, ctrl);
-}
-*/
-
-int		main(void)
-{
-	t_control	ctrl;
-
-	init_mlx(&ctrl);
-	vec3_set(ctrl.cam.polar_pos, 10., HALF_PI, HALF_PI);
-
-
-	mlx_key_hook(ctrl.win_ptr, handle_key, &ctrl);
-	mlx_expose_hook(ctrl.win_ptr, handle_redraw, &ctrl);
-
-	render(&ctrl);
-
-
-	mlx_loop(ctrl.mlx_ptr);
-
-
-	return (0);
-}
diff --git a/rays.c b/rays.c
deleted file mode 100644
index f15316c..0000000
--- a/rays.c
+++ /dev/null
@@ -1,173 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   rays.c                                             :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: fulguritude <marvin@42.fr>                 +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2018/09/16 23:00:36 by fulguritu         #+#    #+#             */
-/*   Updated: 2018/09/16 23:00:57 by fulguritu        ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "rtv1.h"
-#if 0
-/*
-** has_inter refers to a single ray test with a single object here
-** tmp is first quaddist from camera to contact; then intensity of the pixel
-** (lum)
-*/
-
-static t_bool		ray_handle_sphere(t_control *ctrl, t_ray const ray
-								t_sphere sphr, t_float *ray.t)
-{
-	t_vec_3d	contact_pt;
-	t_vec_3d	contact_nrml;
-	t_vec_3d	contact_dirlgt;
-	t_bool		has_inter;
-	t_float		tmp;
-
-	if (!(has_inter = intersect_ray_sphere(contact_pt, contact_nrml, ray, sphr))
-		return (FALSE);
-	tmp = vec3_eucl_quaddist(contact_pt, ray.origin);
-	if (has_inter && tmp < *ray.t) //one line to gain with double if assignment
-	{
-		*ray.t = tmp;
-		vec3_sub(contact_dirlgt, ctrl->spot.origin, contact_pt);
-		tmp = 1. / vec3_quadnorm(contact_dirlgt);
-		vec3_nrmlz(contact_dirlgt, contact_dirlgt); //vec3_scale(sqrt(tmp), contact_dirlgt); should also work logically
-		tmp = INV_PI * sphr.albedo * ctrl->spot.intensity
-				* ft_max(0., vec3_dot(contact_nrml, contact_dirlgt));
-	}
-
-	((t_u32 *)ctrl->img_data)[pixel]
-	return (has_inter);
-}
-
-/*
-** has_inter refers to a single ray tested with the full list of objects here
-*/
-
-static t_bool	cast_ray_to_objs(t_control *ctrl, t_objlst const ol,
-								t_ray const ray, int pixel)
-{
-	t_bool		has_inter;
-	int			obj_k;
-	t_float		ray.t;
-
-	obj_k = 0;
-	has_inter = FALSE;
-	ray.t = 1. / 0.;
-	while (obj_k < ol.len)
-	{
-		if (ol.objs[obj_k].type == sphere)
-			ray_handle_sphere(ctrl, ray, ol.objs[obj_k].data.sphere, &ray.t);
-		else if (ol.objs[obj_k].type != sphere)
-			exit_error("cast_ray_to_objs: malformed object.", 0);
-		++obj_k;
-	}
-	return (has_inter);
-}
-#endif
-
-t_color			color_app_lum(t_vec_3d lum)//t_color clr, t_vec_3d lum)
-{
-	t_u8		red;
-	t_u8		grn;
-	t_u8		blu;
-
-//printf("lum: %f\n", lum);
-	red = ft_fmax(0., ft_fmin(255., lum[0]));//(clr >> 16) * lum[0];
-	grn	= ft_fmax(0., ft_fmin(255., lum[1]));//(clr >> 8) * lum[1];
-	blu = ft_fmax(0., ft_fmin(255., lum[2]));//(clr) * lum[2];
-	return (red << 16 | grn << 8 | blu);
-}
-
-
-
-#if 0
-/*
-** Principle: you cast a ray from the point of contact in question to the light
-** source(s) and if it intersects with an object, and 
-** 		dist(contact, light) > dist(contact, shadow_ray_contact)
-** then the contact point is hidden from the light source
-*/
-static t_bool	cast_shadow_ray()
-{
-
-}
-#endif
-
-
-
-static t_bool	cast_ray_to_objs(t_control *ctrl, t_objlst const ol,
-								t_ray ray, int pixel) //maybe make pixel an int* and rm ctrl for subfunction
-{
-	t_bool		has_inter;
-	t_vec_3d	contact_pt;
-	t_vec_3d	contact_nrml;
-	t_vec_3d	contact_dirlgt;
-	t_float		tmp;
-	t_vec_3d	lum;
-	int			obj_k;
-
-	obj_k = 0;
-	has_inter = FALSE;
-	while (obj_k < ol.len)
-	{
-		if (ol.objs[obj_k].type == sphere
-		&& (has_inter = intersect_ray_sphere(&ray, ol.objs[obj_k].data.sphere)))
-		{
-			sphere_get_ctt_n_nrml(contact_pt, contact_nrml, ray, ol.objs[obj_k].data.sphere);
-			vec3_sub(contact_dirlgt, ctrl->spot.origin, contact_pt);
-			tmp = vec3_eucl_quadnorm(contact_dirlgt);
-//
-			tmp = 1. / tmp;
-			vec3_scale(contact_dirlgt, sqrt(tmp), contact_dirlgt); ////vec3_eucl_nrmlz(contact_dirlgt, contact_dirlgt); is the costlier version
-			
-			vec3_scale(
-				lum,
-				INV_PI * ctrl->spot.intensity * ft_fmax(0., vec3_dot(contact_nrml, contact_dirlgt)) * tmp,
-				ol.objs[obj_k].data.sphere.albedo);
-			((t_u32 *)ctrl->img_data)[pixel] = color_app_lum(lum);
-		}
-		else if (ol.objs[obj_k].type != sphere)
-			exit_error("cast_ray_to_objs: malformed object.", 0);
-		++obj_k;
-	}
-	return (has_inter);
-}
-
-/*
-** Rays are defined in Cam Space then sent to World Space.
-**
-** Intersections should be tested for in world space
-*/
-
-void			cast_rays(t_control *ctrl, t_objlst const objlst)
-{
-	int			i;
-	int			j;
-	t_ray		ray;
-	t_vec_4d	tmp;
-	t_float		fov_val;
-
-	fov_val = -REN_W / (2 * tan(ctrl->cam.hrz_fov));
-	i = 0;
-	while (i < REN_H)
-	{
-		j = 0;
-		while (j < REN_W)
-		{
-			vec3_cpy(ray.origin, (t_float *)ctrl->cam.c_to_w + 12);//ctrl->cam.world_pos);
-			ray.t = 1. / 0.;
-			vec3_set(tmp, j - REN_W / 2, i - REN_H / 2, fov_val);
-			tmp[3] = 1.;
-			mat44_app_vec(tmp, ctrl->cam.c_to_w, tmp);
-			vec3_eucl_nrmlz(ray.dir, tmp);
-			cast_ray_to_objs(ctrl, objlst, ray, i * REN_W + j);
-			++j;
-		}
-		++i;
-	}
-}
diff --git a/render.c b/render.c
deleted file mode 100644
index c8deba4..0000000
--- a/render.c
+++ /dev/null
@@ -1,112 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   render.c                                           :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: fulguritude <marvin@42.fr>                 +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2018/09/17 00:08:48 by fulguritu         #+#    #+#             */
-/*   Updated: 2018/09/17 00:09:00 by fulguritu        ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "rtv1.h"
-
-int			handle_redraw(void *param)
-{
-	t_control	*ctrl;
-
-	ctrl = (t_control *)param;
-	mlx_put_image_to_window(ctrl->mlx_ptr, ctrl->win_ptr, ctrl->img_ptr, 0, 0);
-	return (0);
-}
-
-static void		show_debug_info(t_control *ctrl)
-{
-	char	*str;
-
-	str = NULL;
-	ft_asprintf(&str, "polar: (nrm: %.4f, lon: %.4f, lat: %.4f)",
-		ctrl->cam.polar_pos[0], ctrl->cam.polar_pos[1], ctrl->cam.polar_pos[2]);
-	mlx_string_put(ctrl->mlx_ptr, ctrl->win_ptr, 20, 20, WHITE, str);
-	ft_strdel(&str);
-	ft_asprintf(&str, "world: (x  : %.4f, y  : %.4f, z  : %.4f)",
-		ctrl->cam.world_pos[0], ctrl->cam.world_pos[1], ctrl->cam.world_pos[2]);
-	mlx_string_put(ctrl->mlx_ptr, ctrl->win_ptr, 20, 40, WHITE, str);
-	ft_strdel(&str);
-//	ft_asprintf(&str, "", );
-//	mlx_string_put(ctrl->mlx_ptr, ctrl->win_ptr, 20, 60, WHITE, str);
-//	ft_strdel(&str);
-//	ft_asprintf(&str, "h_ratio: %.4f", ctrl->fdf.h_scale);
-//	mlx_string_put(ctrl->mlx_ptr, ctrl->win_ptr,
-//		HALF_DRENWIN_WIDTH + 20, 80, WHITE, str);
-//	ft_strdel(&str);
-//	mlx_string_put(ctrl->mlx_ptr, ctrl->win_ptr, HALF_DRENWIN_WIDTH + 20,
-//		100, GREEN, str);
-}
-
-void			render(t_control *ctrl)
-{
-//	t_mat_4b4	w_to_v;
-
-//	mlximg_clear(ctrl);
-	ctrl->cam = init_cam(ctrl->cam.polar_pos);
-	mlximg_fill(ctrl, BG_COLOR);
-
-
-	t_objlst	test;
-	t_light_src	spot;
-
-	test.len = 5;
-
-	test.objs[0].type = sphere;
-	vec3_set(test.objs[0].data.sphere.center, 0., 0., -10.);
-	test.objs[0].data.sphere.radius = 3.;
-	test.objs[0].data.sphere.color = RED / 4 * 3;
-	vec3_set(test.objs[0].data.sphere.albedo, 1., 0., 0.);
-
-	test.objs[1].type = sphere;
-	vec3_set(test.objs[1].data.sphere.center, 5., 5., -9.);
-	test.objs[1].data.sphere.radius = 2.;
-	test.objs[1].data.sphere.color = GREEN / 4 * 3;
-	vec3_set(test.objs[1].data.sphere.albedo, 0., 1., 0.);
-
-	test.objs[2].type = sphere;
-	vec3_set(test.objs[2].data.sphere.center, 1., -1., -7.75);
-	test.objs[2].data.sphere.radius = 1.;
-	test.objs[2].data.sphere.color = BLUE / 4 * 3;
-	vec3_set(test.objs[2].data.sphere.albedo, 0., 0., 1.);
-
-	test.objs[3].type = sphere;
-	vec3_set(test.objs[3].data.sphere.center, 0., 0., 0.);
-	test.objs[3].data.sphere.radius = 1.;
-	test.objs[3].data.sphere.color = BLACK;// / 4 * 3;
-	vec3_set(test.objs[3].data.sphere.albedo, 0.07, 0.07, 0.07);
-
-	test.objs[4].type = sphere;
-	vec3_set(test.objs[4].data.sphere.center, -10., -10., 10.);
-	test.objs[4].data.sphere.radius = 1.;
-	test.objs[4].data.sphere.color = DBG_COLOR;// / 4 * 3;
-	vec3_set(test.objs[4].data.sphere.albedo, 1., 0., 1.);
-
-/*
-	for (int i = 0; i < test.len; ++i)
-		if (test.objs[i].type == sphere)
-			sphere_wtov(&(test.objs[i].data.sphere), ctrl->cam);
-		else
-			exit_error("render: malformed object", 0);
-*/
-
-	vec3_set(spot.origin, 1., 10., 15.);
-	spot.intensity = 500000.;
-
-	ctrl->spot = spot;
-	
-
-	cast_rays(ctrl, test);
-	mlx_put_image_to_window(ctrl->mlx_ptr, ctrl->win_ptr, ctrl->img_ptr, 0, 0);
-
-	if (ctrl->debug)
-		show_debug_info(ctrl);
-	
-}
diff --git a/src/intersect.c b/src/intersect.c
index a073bd0..b495fff 100644
--- a/src/intersect.c
+++ b/src/intersect.c
@@ -12,6 +12,59 @@
 
 #include "rtv1.h"
 
+#if 0
+-/*
+-** Should sphr.center in world_pos or view_pos ?
+-**
+-** Replace with a t_vec3 for coefs ?
+-**
+-** replace everything with ray as a pointer with t = inf at first, and return
+-** false if the intersection is behind (o + t*dir)  ? 
+-*/
+-t_bool         intersect_ray_sphere(t_ray *ray, t_sphere const sphr)
+-{
+-       t_float         delta;
+-       t_float         b;
+-       t_float         c;
+-       t_float         root1;
+-       t_float         root2;
+-       t_vec_3d        orig_to_sphr;
+-
+-       vec3_sub(orig_to_sphr, ray->origin, sphr.center);
+-       b = 2 * vec3_dot(ray->dir, orig_to_sphr);
+-       c = vec3_eucl_quadnorm(orig_to_sphr) - sphr.radius * sphr.radius;
+-       delta = b * b - 4 * c;
+-       if (delta < 0.)
+-               return (FALSE);
+-       delta = sqrt(delta);
+-       root1 = (-b + delta) * 0.5;
+-       root2 = (-b - delta) * 0.5;
+-       if (root1 <= 0. || root2 <= 0. || (root1 > ray->t && root2 > ray->t))
+-               return (FALSE);
+-       ray->t = ft_fmin(root1, root2);
+-       return (TRUE);
+-}
+-
+-void           sphere_get_ctt_n_nrml(t_vec_3d contact, t_vec_3d normal,
+-                                                                       t_ray const ray, t_sphere const sphr)
+-{
+-       vec3_scale(contact, ray.t, ray.dir);
+-       vec3_add(contact, contact, ray.origin); //pos relative to ray->origin, which itself should be in world_pos
+-       vec3_sub(normal, contact, sphr.center);
+-       vec3_scale(normal, 1. / sphr.radius, normal);
+-}
+-
+-void           sphere_wtoc(t_sphere *sphr, t_camera const cam)
+-{
+-       t_vec_4d        tmp;
+-
+-       vec3_cpy(tmp, sphr->center);
+-       tmp[3] = 1.;
+-       mat44_app_vec(tmp, cam.w_to_c, tmp);
+-       vec3_cpy(sphr->center, tmp);
+-}
+#endif
+
 //rename sphere_intersect_ray and make this sphere.c ?
 
 /*
@@ -27,6 +80,7 @@ t_bool		intersect_ray_sphere(t_ray *objray)//, t_object const sphr)
 {
 	t_float		delta;
 //	t_vec_4d	tmps;
+	t_float		a;
 	t_float		b;
 	t_float		c;
 	t_float		root1;
@@ -36,14 +90,17 @@ t_bool		intersect_ray_sphere(t_ray *objray)//, t_object const sphr)
 
 //printf("objray: origin-(%f, %f, %f); dir-(%f, %f, %f)\n", objray->origin[0], objray->origin[1], objray->origin[2], objray->dir[0], objray->dir[1], objray->dir[2]);
 //	vec3_sub(orig_to_sphr, objray->origin, sphr.center);
+	a = vec3_eucl_quadnorm(objray->dir);
 	b = 2 * vec3_dot(objray->dir, objray->origin);
 	c = vec3_eucl_quadnorm(objray->origin) - 1.;
-	delta = b * b - 4 * c;
+	delta = b * b - 4 * a * c;
 	if (delta < 0.)
 		return (FALSE);
+	a = 0.5 / a;
 	delta = sqrt(delta);
-	root1 = (-b + delta) * 0.5;
-	root2 = (-b - delta) * 0.5;
+	root1 = (-b + delta) * a;
+	root2 = (-b - delta) * a;
+//printf("delta: %6f\troot1: %6f\troot2: %6f\tobjray.t: %6f\n", delta, root1, root2, objray->t);
 	if (root1 <= 0. || root2 <= 0. || (root1 > objray->t && root2 > objray->t))
 		return (FALSE);
 	objray->t = ft_fmin(root1, root2);
@@ -61,10 +118,9 @@ void		get_cnn_sphere(t_vec_3d contact, t_vec_3d normal,
 									t_ray const objray)//, t_object const sphr)
 {
 	vec3_scale(contact, objray.t, objray.dir);
+	vec3_add(contact, contact, objray.origin);
+//printf("Should be 1.: %f\n", vec3_eucl_quadnorm(contact));
 	vec3_cpy(normal, contact);
-	vec3_add(contact, contact, objray.origin); //pos relative to ray->origin, which itself should be in world_pos
-//vec3_sub(normal, contact, sphr.center);
-//vec3_scale(normal, 1. / sphr.radius, normal);
 }
 
 
diff --git a/src/objects.c b/src/objects.c
index 082757e..4c75bcb 100644
--- a/src/objects.c
+++ b/src/objects.c
@@ -36,10 +36,13 @@ static t_object		init_object(t_vec_3d const world_pos,
 	vec3_cpy(res.albedo, rgb_albedo);
 	mat33_rot(rot, res.rot[0], 0);
 	mat33_rot(tmp, res.rot[1], 1);
+//printf("y_rot_mat:\n\tx: (%.5f, %.5f, %.5f)\n\ty: (%.5f, %.5f, %.5f)\n\tz: (%.5f, %.5f, %.5f)\n\n", tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8]);
 	mat33_mul(rot, tmp, rot);
 	mat33_rot(tmp, res.rot[2], 2);
 	mat33_mul(rot, tmp, rot);
 	mat33_set_diagmat(tmp, res.scl);
+printf("scale_diag_mat:\n\tx: (%.5f, %.5f, %.5f)\n\ty: (%.5f, %.5f, %.5f)\n\tz: (%.5f, %.5f, %.5f)\n\n", tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8]);
+
 	mat33_mul(rot, rot, tmp);
 	ft_memcpy(trans, (t_vec_4d){res.pos[0], res.pos[1], res.pos[2], 1.}, sizeof(t_vec_4d));
 	mat44_set(res.o_to_w, rot, (t_vec_3d){0., 0., 0.}, trans);
@@ -61,6 +64,11 @@ res.w_to_o[12], res.w_to_o[13], res.w_to_o[14], res.w_to_o[15]);
 	return (res);
 }
 
+void				print_object(t_object const obj)
+{
+	printf("pos: (%f, %f, %f)\nscl: (%f, %f, %f)\nrot: (%f, %f, %f)\nabd: (%f, %f, %f)\n", obj.pos[0], obj.pos[1], obj.pos[2],  obj.scl[0], obj.scl[1], obj.scl[2], obj.rot[0], obj.rot[1], obj.rot[2], obj.albedo[0], obj.albedo[1], obj.albedo[2]);
+}
+
 void				init_objects(t_control *ctrl)
 {
 //	t_list		*objlst;
@@ -75,11 +83,24 @@ void				init_objects(t_control *ctrl)
 	ctrl->spot.intensity = 500000.;
 	ctrl->objlst_len = 0;
 
-//BLACK
+//TMP
+/*
 	vec3_cpy(world_pos, (t_vec_3d){0., 0., 0.});
 	vec3_cpy(xyz_scaling, (t_vec_3d){1., 1., 1.});
 	vec3_cpy(xyz_rot_rad, (t_vec_3d){0., 0., 0.});
-	vec3_cpy(rgb_albedo, (t_vec_3d){0.07, 0.07, 0.07});
+	vec3_cpy(rgb_albedo, (t_vec_3d){0.7, 0., 0.7});
+	tmp = init_object(world_pos, xyz_scaling, xyz_rot_rad, rgb_albedo);
+	tmp.type = sphere;
+	tmp.intersect = &intersect_ray_sphere;
+	tmp.get_cnn = &get_cnn_sphere;
+	ctrl->objlst[(ctrl->objlst_len)++] = tmp;
+*/
+
+//BLACK
+	vec3_cpy(world_pos, (t_vec_3d){0., 0., 0.});
+	vec3_cpy(xyz_scaling, (t_vec_3d){1., 2., 3.});
+	vec3_cpy(xyz_rot_rad, (t_vec_3d){0., 0., 0.});
+	vec3_cpy(rgb_albedo, (t_vec_3d){0.1, 0.1, 0.1});
 	tmp = init_object(world_pos, xyz_scaling, xyz_rot_rad, rgb_albedo);
 	tmp.type = sphere;
 	tmp.intersect = &intersect_ray_sphere;
@@ -120,13 +141,14 @@ void				init_objects(t_control *ctrl)
 	ctrl->objlst[(ctrl->objlst_len)++] = tmp;
 
 //PURPLE
-	vec3_cpy(world_pos, (t_vec_3d){-10., -10., 10.});
-	vec3_cpy(xyz_scaling, (t_vec_3d){0.5, 1., 2.});
+	vec3_cpy(world_pos, (t_vec_3d){0.5, 0.5, -0.5});
+	vec3_cpy(xyz_scaling, (t_vec_3d){1., 1., 1.});
 	vec3_cpy(xyz_rot_rad, (t_vec_3d){0., 0., 0.});
-	vec3_cpy(rgb_albedo, (t_vec_3d){HALF_PI, HALF_PI, HALF_PI});
+	vec3_cpy(rgb_albedo, (t_vec_3d){1., 0., 1.});
 	tmp = init_object(world_pos, xyz_scaling, xyz_rot_rad, rgb_albedo);
 	tmp.type = sphere;
 	tmp.intersect = &intersect_ray_sphere;
 	tmp.get_cnn = &get_cnn_sphere;
 	ctrl->objlst[(ctrl->objlst_len)++] = tmp;
+
 }
diff --git a/src/rays.c b/src/rays.c
index 644e396..9e9c0e2 100644
--- a/src/rays.c
+++ b/src/rays.c
@@ -11,64 +11,6 @@
 /* ************************************************************************** */
 
 #include "rtv1.h"
-#if 0
-/*
-** has_inter refers to a single ray test with a single object here
-** tmp is first quaddist from camera to contact; then intensity of the pixel
-** (lum)
-*/
-
-static t_bool		ray_handle_sphere(t_control *ctrl, t_ray const ray
-								t_sphere sphr, t_float *ray.t)
-{
-	t_vec_3d	contact_pt;
-	t_vec_3d	contact_nrml;
-	t_vec_3d	contact_dirlgt;
-	t_bool		has_inter;
-	t_float		tmp;
-
-	if (!(has_inter = intersect_ray_sphere(contact_pt, contact_nrml, ray, sphr))
-		return (FALSE);
-	tmp = vec3_eucl_quaddist(contact_pt, ray.origin);
-	if (has_inter && tmp < *ray.t) //one line to gain with double if assignment
-	{
-		*ray.t = tmp;
-		vec3_sub(contact_dirlgt, ctrl->spot.origin, contact_pt);
-		tmp = 1. / vec3_quadnorm(contact_dirlgt);
-		vec3_nrmlz(contact_dirlgt, contact_dirlgt); //vec3_scale(sqrt(tmp), contact_dirlgt); should also work logically
-		tmp = INV_PI * sphr.albedo * ctrl->spot.intensity
-				* ft_max(0., vec3_dot(contact_nrml, contact_dirlgt));
-	}
-
-	((t_u32 *)ctrl->img_data)[pixel]
-	return (has_inter);
-}
-
-/*
-** has_inter refers to a single ray tested with the full list of objects here
-*/
-
-static t_bool	cast_ray_to_objs(t_control *ctrl, t_objlst const ol,
-								t_ray const ray, int pixel)
-{
-	t_bool		has_inter;
-	int			k;
-	t_float		ray.t;
-
-	k = 0;
-	has_inter = FALSE;
-	ray.t = 1. / 0.;
-	while (k < ol.len)
-	{
-		if (ol.objs[k].type == sphere)
-			ray_handle_sphere(ctrl, ray, ctrl->objlst[k], &ray.t);
-		else if (ol.objs[k].type != sphere)
-			exit_error("cast_ray_to_objs: malformed object.", 0);
-		++k;
-	}
-	return (has_inter);
-}
-#endif
 
 #if 0
 /*
@@ -89,7 +31,7 @@ t_color			color_app_lum(t_vec_3d lum)//t_color clr, t_vec_3d lum)
 	t_u8		grn;
 	t_u8		blu;
 
-//printf("lum: %f\n", lum);
+//printf("lum: % .3f\n", lum);
 	red = ft_fmax(0., ft_fmin(255., lum[0]));//(clr >> 16) * lum[0];
 	grn	= ft_fmax(0., ft_fmin(255., lum[1]));//(clr >> 8) * lum[1];
 	blu = ft_fmax(0., ft_fmin(255., lum[2]));//(clr) * lum[2];
@@ -104,16 +46,58 @@ void			mat44_app_vec3(t_vec_3d result, t_mat_4b4 const mat, t_vec_3d const v)
 	vec3_cpy(result, tmp);
 }
 
-t_ray			ray_w_to_o(t_mat_4b4 const w_to_o, t_ray const ray)
+t_ray			ray_x_to_y(t_mat_4b4 const x_to_y, t_ray const ray)
 {
 	t_ray		result;
 
-	mat44_app_vec3(result.origin, w_to_o, ray.origin);
-	mat44_app_vec3(result.dir, w_to_o, ray.dir);
+	mat44_app_vec3(result.origin, x_to_y, ray.origin);
+	mat44_app_vec3(result.dir, x_to_y, ray.dir);
+	result.t = ray.t;
 	return (result);
 }
 
-static t_bool	cast_ray_to_objs(t_control *ctrl, t_ray const ray, int pixel)
+#if 0
+-static t_bool  cast_ray_to_objs(t_control *ctrl, t_objlst const ol,
+-                                                               t_ray ray, int pixel) //maybe make pixel an int* and rm ctrl for subfunction
+-{
+-       t_bool          has_inter;
+-       t_vec_3d        contact_pt;
+-       t_vec_3d        contact_nrml;
+-       t_vec_3d        contact_dirlgt;
+-       t_float         tmp;
+-       t_vec_3d        lum;
+-       int                     obj_k;
+-
+-       obj_k = 0;
+-       has_inter = FALSE;
+-       while (obj_k < ol.len)
+-       {
+-               if (ol.objs[obj_k].type == sphere
+-               && (has_inter = intersect_ray_sphere(&ray, ol.objs[obj_k].data.sphere)))
+-               {
+-                       sphere_get_ctt_n_nrml(contact_pt, contact_nrml, ray, ol.objs[obj_k].data.sphere);
+-                       vec3_sub(contact_dirlgt, ctrl->spot.origin, contact_pt);
+-                       tmp = vec3_eucl_quadnorm(contact_dirlgt);
+-//
+-                       tmp = 1. / tmp;
+-                       vec3_scale(contact_dirlgt, sqrt(tmp), contact_dirlgt); ////vec3_eucl_nrmlz(contact_dirlgt, contact_dirlgt); is the c
+ostlier version
+-                       
+-                       vec3_scale(
+-                               lum,
+-                               INV_PI * ctrl->spot.intensity * ft_fmax(0., vec3_dot(contact_nrml, contact_dirlgt)) * tmp,
+-                               ol.objs[obj_k].data.sphere.albedo);
+-                       ((t_u32 *)ctrl->img_data)[pixel] = color_app_lum(lum);
+-               }
+-               else if (ol.objs[obj_k].type != sphere)
+-                       exit_error("cast_ray_to_objs: malformed object.", 0);
+-               ++obj_k;
+-       }
+-       return (has_inter);
+-}
+#endif
+
+static t_bool	cast_ray_to_objs(t_control *ctrl, t_ray ray, int pixel)
 {
 	t_bool		has_inter;
 	t_vec_3d	contact_pt;
@@ -122,7 +106,7 @@ static t_bool	cast_ray_to_objs(t_control *ctrl, t_ray const ray, int pixel)
 	t_float		tmp;
 	t_vec_3d	lum;
 	t_ray		objray;
-//	t_light_src	objspot;
+	t_light_src	objspot;
 	int			k;
 	t_object	cur_obj;
 
@@ -131,18 +115,26 @@ static t_bool	cast_ray_to_objs(t_control *ctrl, t_ray const ray, int pixel)
 	while (k < ctrl->objlst_len)
 	{
 		cur_obj = ctrl->objlst[k];
-		objray = ray_w_to_o(cur_obj.w_to_o, ray);
+		objray = ray_x_to_y(cur_obj.w_to_o, ray);
 //		mat44_app_vec3(objspot.origin, cur_obj.w_to_o, ctrl->spot.origin);
 		if ((has_inter = cur_obj.intersect(&objray)))//, cur_obj)))
 		{
-			cur_obj.get_cnn(contact_pt, contact_nrml, objray);//, cur_obj);
-			mat44_app_vec3(contact_pt, cur_obj.o_to_w, contact_pt);
-			mat44_app_vec3(contact_nrml, cur_obj.o_to_w, contact_nrml);
-			vec3_eucl_nrmlz(contact_nrml, contact_nrml);
-			vec3_sub(contact_dirlgt, ctrl->spot.origin, contact_pt);
+//printf("k: %d | ray: (% .3f, % .3f, % .3f) + % .3f * (% .3f, % .3f, % .3f)\n", k, objray.origin[0], objray.origin[1], objray.origin[2], objray.t, objray.dir[0], objray.dir[1], objray.dir[2]);
+			ray.t = objray.t;
+			cur_obj.get_cnn(contact_pt, contact_nrml, objray);
+//printf("1- contact_pt: (% .3f, % .3f, % .3f)\tcontact_nrml: (% .3f, % .3f, % .3f)\n", contact_pt[0], contact_pt[1], contact_pt[2], contact_nrml[0], contact_nrml[1], contact_nrml[2]);
+		mat44_app_vec3(contact_pt, cur_obj.o_to_w, contact_pt);
+		mat44_app_vec3(contact_nrml, cur_obj.o_to_w, contact_nrml);
+	    vec3_add(contact_nrml, contact_nrml, (t_float *)cur_obj.o_to_w + 12);
+		vec3_eucl_nrmlz(contact_nrml, contact_nrml);
+//printf("2- contact_pt: (% .3f, % .3f, % .3f)\tcontact_nrml: (% .3f, % .3f, % .3f)\n\n", contact_pt[0], contact_pt[1], contact_pt[2], contact_nrml[0], contact_nrml[1], contact_nrml[2]);
+		//objspot = ctrl->spot;
+		//mat44_app_vec3(objspot.origin, cur_obj.w_to_o, objspot.origin);
+			vec3_sub(contact_dirlgt, objspot.origin, contact_pt);
 			tmp = vec3_eucl_quadnorm(contact_dirlgt);
 			tmp = 1. / tmp;
-			vec3_scale(contact_dirlgt, sqrt(tmp), contact_dirlgt); ////vec3_eucl_nrmlz(contact_dirlgt, contact_dirlgt); is the costlier version
+			vec3_scale(contact_dirlgt, sqrt(tmp), contact_dirlgt); //less costly
+			//vec3_eucl_nrmlz(contact_dirlgt, contact_dirlgt); //is the costlier version
 			
 			vec3_scale(
 				lum,
