/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   rtv1.h                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fulguritude <marvin@42.fr>                 +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2018/08/30 17:34:32 by fulguritu         #+#    #+#             */
/*   Updated: 2018/09/10 03:17:05 by fulguritu        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef RTV1_H
# define RTV1_H

# include "libft/hdr/libft.h"
# include "libft/hdr/libft_algebra.h"
# include "libft/hdr/ft_printf.h"
# include "mlx_event_lin.h"
# include <fcntl.h>
# include <sys/types.h>
# include <sys/stat.h>
# include <stdio.h>
# include <mlx.h>
# include <errno.h>

# define REN_W		480
# define REN_H		360

# define BLACK			0x000000
# define RED			0xFF0000
# define GREEN			0x00FF00
# define BLUE			0x0000FF
# define WHITE			0xFFFFFF
# define DBG_COLOR		0x5500BB
# define BG_COLOR		0x00BB88
# define NO_INTER		0xFF000000

# define MAX_OBJ_NB		32

typedef struct	s_point
{
	int		x;
	int		y;
}				t_point;

typedef t_u32	t_color;

/*
** CAMERA
**
** world_pos		: cartesian coordinate of camera in world
** reltv_pos		: cartesian coordinate of camera with anchor as center
** polar_pos		: zoom/radius, longitude, latitude relative to anchor
** anchor			: origin of polar_pos and reltv_pos
** axis_x			: right vector of cam
** axis_y			: up vector of cam
** axis_z			: "forward" vector of cam,  input eye vector
** hrz_fov			: field-of-view horizontal angle in radians
** w_to_v			: the camera's world-to-view matrix
*/
typedef struct	s_camera
{
	t_vec_3d		world_pos;
//	t_vec_3d		reltv_pos;
	t_vec_3d		polar_pos;
	t_vec_3d		anchor;
	t_vec_3d		axis_x;
	t_vec_3d		axis_y;
	t_vec_3d		axis_z;
	t_float			hrz_fov;
	t_mat_4b4		c_to_w;
	t_mat_4b4		w_to_c;
}				t_camera;

/*
** RAYS AND SHADING
**
** Rays can be interpreted in any space.
** origin + scale(t, dir) = end of the current ray
*/
typedef struct	s_ray
{
	t_vec_3d	origin;
	t_vec_3d	dir;
	t_float		t;
}				t_ray;

typedef struct	s_light_src
{
	t_vec_3d	origin;
	t_float		intensity;
}				t_light_src;

/*
** PRIMITIVES
**
** 'cuboid' is of course 'parallelepiped' but that word's too ugly.
*/
typedef	enum	e_objtype
{
	sphere,
	plane,
	cylinder,
	cone,
	cuboid
}				t_objtype;

typedef struct	s_sphere
{
	t_vec_3d	center;
	t_float		radius;
	t_u32		color;
	t_vec_3d	albedo;
}				t_sphere;

typedef struct	s_plane
{
	t_vec_3d	normal;
	t_float		y_offset;
	t_u32		color;
	t_float		albedo;
}				t_plane;

typedef union	u_objuni
{
	t_sphere	sphere;
	t_plane		plane;
	//t_cone	cone;
	//t_cylndr	cylinder;
}				t_objuni;

/*
** IF (obj.type == sphere) THEN intersect_sphere(ray, obj.data.sphere, ...)
*/
typedef struct	s_object
{
	t_objtype	type;
	t_objuni	data;
}				t_object;

typedef struct	s_objlst
{
	t_object	objs[MAX_OBJ_NB];
	int			len;
}				t_objlst;

/*
** SOFTWARE CONTROL TABLE
*/
typedef struct	s_control
{
	void			*mlx_ptr;
	void			*win_ptr;
	void			*img_ptr;
	int				img_bpp;
	int				img_bpl;
	int				img_bytelen;
	int				img_pixel_nb;
	int				endian;
	char			*img_data;
	t_camera		cam;
	int				debug;
	t_point			mouse;
	t_objlst		ol;
	t_light_src		spot;
}				t_control;

/*
FOV is the angle centered on the camera, and that spans 0 to width - 1
	horizontally.

GEtting a ray's direction from the FOV angle:
x = j - W/2
y = i - H/2
z = - W/(2*tan(FOV/2))
=> this formula produces the vectors for a camera facing from +z to -z, positive
x on the right, and positive y towards the bottom

Sphere/ray intersection
't' is the parameter that allows one to know where on the line generated by a ray they are (cur_point = origin + t * dir)
'center' is the sphere's center, 'radius' its radius

formula : t^2 + 2*t*<dir,origin - center> + quadnorm(origin - center) - radius^2 == 0

roots of the polynomial exist iff there is intersection (so use the discriminant of a degree 2 polynomial), and these roots (t1 and t2) are negative iff the object is behind the camera origin. If the roots are of different sign, then the camera origin is located inside the sphere


Lambertian lighting model:

a contact point on a sphere is lighted according to the formula (albedo * light_intensity * <N, L>)/ (pi * quaddist(contact, light_spot))

-where albedo is an coefficient between 0 and 1 defining how much light is reflected, and you generally (for physical realism) divide the albedo by PI, hence the pi in the formula
-where N is the unit normal on the object at the contact point
-where L is the unit vector from contact to light_spot)
*/


void			exit_error(char *e_msg, int e_no);

/*
** image_utils.c
*/
int				point_in_bounds(int x, int y);
void			mlximg_setpixel(t_control *ctrl, int color, int x, int y);
void			mlximg_fill(t_control *ctrl, t_u32 val);
void			mlximg_clear(t_control *ctrl);

/*
** camera.c
*/
t_camera		init_cam(t_vec_3d polar_cam_pos);
//static void			cam_to_mat(t_mat_4b4 result, t_camera const cam);

/*
** render.c
*/
int				handle_redraw(void *param);
void			render(t_control *ctrl);

/*
** coordinates.c
*/
void			vec3_polar_to_cartesian(t_vec_3d result, t_vec_3d const src);
void			vec3_cartesian_to_polar(t_vec_3d result, t_vec_3d const src);

/*
** event_key.c
*/
int				handle_key(int key, void *param);

/*
** intersect.c
*/
t_bool			intersect_ray_sphere(t_ray *ray, t_sphere const sphr);
void			sphere_get_ctt_n_nrml(t_vec_3d contact, t_vec_3d normal,
									t_ray const ray, t_sphere const sphr);

void		sphere_wtov(t_sphere *sphr, t_camera const cam);

/*
** rays.c
*/
void			cast_rays(t_control *ctrl, t_objlst const objs);

#endif
