/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cone.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fulguritude <marvin@42.fr>                 +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2018/09/27 19:23:31 by fulguritu         #+#    #+#             */
/*   Updated: 2018/09/27 19:23:39 by fulguritu        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "rtv1.h"

/*
** Returns the dot product where the y component is prescaled by
**	i = sqrt(-1) in both inputs; useful for solving x^2 + z^2 == y^2, as the
**	kernel of this function is the solution
*/

static inline t_float	vec3_yneg_dot(t_vec_3d const v1, t_vec_3d const v2)
{
	return (v1[0] * v2[0] - v1[1] * v2[1] + v1[2] * v2[2]);
}

/*
** The infcone primitive is the set of points made up by all rotations around
** the y axis of the subspace (here, line) generated by the vector (1., 1., 0.).
**
** Any point on this primitive verifies x^2 + z^2 == y^2; thus one must find
**	r = o + td
**	(o+td)_x^2 + (o+td)_z^2 - (o+td)_y^2			== 0		<=>
**
**	(ox + t dx)^2 + (oz + t dz)^2 - (oy + t dy)^2	== 0		<=>
**
**	(ox^2 + oz^2 - oy^2)				+						<=>
**	2 * (oxdx + ozdz - oydy)	* t		+
**	(dx^2 + dz^2 - dy^2)		* t^2				== 0
*/

t_bool			intersect_ray_infcone(t_ray *objray)
{
	t_vec_3d	quadpoly;
	t_float		root1;
	t_float		root2;

	quadpoly[0] = vec3_yneg_dot(objray->dir, objray->dir);
	quadpoly[1] = 2 * vec3_yneg_dot(objray->dir, objray->pos);
	quadpoly[2] = vec3_yneg_dot(objray->pos, objray->pos);
	if (!(get_realroots_quadpoly(&root1, &root2, quadpoly)))
		return (FALSE);
	if (root1 <= 0. && root2 <= 0.)
		return (FALSE);
	if (root1 <= 0.)
		root1 = root2;
	else if (root2 <= 0.)
		root2 = root1;
	if (root1 > objray->t && root2 > objray->t)
		return (FALSE);
	objray->t = ft_fmin(root1, root2);
	return (TRUE);
}

/*
** The cone primitive is an infcone from 0. to 1. on the y axis, and a circle
** of radius one, in the affine plane "xz + (0, 1, 0)" and centered in (0,1,0).
**
** This means the position of the cone in world space should coincide with
** the point of the cone.
*/

/*
t_bool			intersect_ray_cone()
{
	
}
*/

/*
** Notice that if one reflects hitpos over the xz-plane, one obtains a scaled
**	version of the normal at hitpos.
*/

void			get_hnn_infcone(t_vec_3d hitpos, t_vec_3d normal,
									t_ray const objray)
{
	get_ray_hitpos(hitpos, objray);
	vec3_set(normal, hitpos[0], -hitpos[1], hitpos[2]);
	vec3_eucl_nrmlz(normal, normal);
}
